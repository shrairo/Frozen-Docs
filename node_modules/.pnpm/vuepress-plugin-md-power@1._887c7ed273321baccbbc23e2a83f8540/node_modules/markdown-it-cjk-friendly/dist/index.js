// src/index.ts
import { eastAsianWidthType } from "get-east-asian-width";
import {
  isMdAsciiPunct,
  isPunctChar,
  isWhiteSpace
} from "markdown-it/lib/common/utils.mjs";
function isEmoji(uc) {
  return /^\p{Emoji_Presentation}/u.test(String.fromCodePoint(uc));
}
function isCjkBase(uc) {
  if (uc < 4352) return false;
  const eaw = eastAsianWidthType(uc);
  switch (eaw) {
    case "fullwidth":
    case "halfwidth":
      return true;
    // never be emoji
    case "wide":
      return !isEmoji(uc);
    case "narrow":
      return false;
    case "ambiguous":
      return null;
    case "neutral":
      return /^\p{sc=Hangul}/u.test(String.fromCodePoint(uc));
  }
}
function is2PreviousCjk(uc, prev) {
  return isCjkBase(uc) ?? (prev === 65025 && isQuotationMark(uc));
  function isQuotationMark(uc2) {
    return uc2 === 8216 || uc2 === 8217 || uc2 === 8220 || uc2 === 8221;
  }
}
function isPreviousCjk(uc) {
  return isCjkBase(uc) ?? (917760 <= uc && uc <= 917999);
}
function isNextCjk(uc) {
  return isCjkBase(uc) ?? false;
}
function nonEmojiGeneralUseVS(uc) {
  return uc >= 65024 && uc <= 65038;
}
function markdownItCjkFriendlyPlugin(md) {
  const PreviousState = md.inline.State;
  class CjFriendlyState extends PreviousState {
    scanDelims(start, canSplitWord) {
      const max = this.posMax;
      const marker = this.src.charCodeAt(start);
      const [lastChar, lastCharPos] = getLastCharCode(this.src, start);
      let lastMainChar = lastChar;
      let twoPrevChar = null;
      if (nonEmojiGeneralUseVS(lastChar)) {
        twoPrevChar = getLastCharCode(this.src, lastCharPos)[0];
        if (!/^\p{Zs}/u.test(String.fromCodePoint(twoPrevChar))) {
          lastMainChar = twoPrevChar;
        }
      }
      let pos = start;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      const count = pos - start;
      const nextChar = pos < max ? this.src.codePointAt(pos) : 32;
      const isLastCJKChar = twoPrevChar !== null ? is2PreviousCjk(twoPrevChar, lastChar) : isPreviousCjk(lastChar);
      const isNextCJKChar = isNextCjk(nextChar);
      const isLastPunctChar = isMdAsciiPunct(lastMainChar) || isPunctChar(String.fromCodePoint(lastMainChar));
      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCodePoint(nextChar));
      const isLastNonCjkPunctChar = isLastPunctChar && !isLastCJKChar;
      const isNextNonCjkPunctChar = isNextPunctChar && !isNextCJKChar;
      const isLastWhiteSpace = isWhiteSpace(lastMainChar);
      const isNextWhiteSpace = isWhiteSpace(nextChar);
      const left_flanking = !isNextWhiteSpace && (!isNextNonCjkPunctChar || isLastNonCjkPunctChar || isLastWhiteSpace || isLastCJKChar);
      const right_flanking = !isLastWhiteSpace && (!isLastNonCjkPunctChar || isNextWhiteSpace || isNextNonCjkPunctChar || isNextCJKChar);
      const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
      const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
      return { can_open, can_close, length: count };
      function getLastCharCode(str, pos2) {
        if (pos2 <= 0) {
          return [32, -1];
        }
        const charCode = str.charCodeAt(pos2 - 1);
        if ((charCode & 64512) !== 56320) {
          return [charCode, pos2 - 1];
        }
        const codePoint = str.codePointAt(pos2 - 2);
        return codePoint > 65535 ? (
          // biome-ignore lint/style/noNonNullAssertion: ditto
          [codePoint, pos2 - 2]
        ) : [charCode, pos2 - 1];
      }
    }
  }
  md.inline.State = CjFriendlyState;
}
export {
  markdownItCjkFriendlyPlugin as default
};
