//#region src/common.ts
/**
* Common functions
*
* @module Common
*/
/**
* Asserts that a condition is true
*
* @param condition the condition to assert
* @param message the message to display if the condition is false
*
* @category Common
*/
function assert(condition, message) {
	if (!condition) throw new Error(message || "Assertion failed");
}
/**
* Get the string representation of a value
*
* è·å–å€¼çš„å­—ç¬¦ä¸²è¡¨ç¤º
*
* @category Common
*/
function toString(s) {
	return Object.prototype.toString.call(s);
}
/**
* Get type name of a value
*
* è·å–å€¼çš„ç±»å‹åç§°
*
* @category Common
* @example
* ```ts
* getTypeName(null) // => 'null'
* getTypeName(undefined) // => 'undefined'
* getTypeName({}) // => 'object'
* ```
*/
function getTypeName(s) {
	return s === null ? "null" : typeof s === "object" || typeof s === "function" ? toString(s).slice(8, -1).toLowerCase() : typeof s;
}

//#endregion
//#region src/is.ts
/**
* Type check
*
* @module Is
*/
/**
* Checks if the input is defined
* @category Is
*/
function isDef(v) {
	return typeof v !== "undefined";
}
/**
* Checks if the input is a primitive
* @category Is
*/
function isPrimitive(v) {
	return v === null || typeof v !== "object" && typeof v !== "function";
}
/**
* Checks if the input is a boolean
* @category Is
*/
function isBoolean(v) {
	return typeof v === "boolean";
}
/**
* Checks if the input is a function.
* @category Is
*/
function isFunction(v) {
	return typeof v === "function";
}
/**
* Checks if the input is a number
* @category Is
*/
function isNumber(v) {
	return typeof v === "number";
}
/**
* Checks if the input is a string
* @category Is
*/
function isString(v) {
	return typeof v === "string";
}
/**
* Checks if the input is a symbol
* @category Is
*/
function isSymbol(v) {
	return typeof v === "symbol";
}
/**
* Checks if the input is an object
* @category Is
*/
function isPlainObject(v) {
	return getTypeName(v) === "object";
}
/**
* Checks if the input is an array
* @category Is
*/
function isArray(v) {
	return Array.isArray(v);
}
/**
* Checks if the input is undefined
*/
function isUndefined(v) {
	return typeof v === "undefined";
}
/**
* Checks if the input is null
* @category Is
*/
function isNull(v) {
	return getTypeName(v) === "null";
}
/**
* Checks if the input is a regexp
* @category Is
*/
function isRegexp(v) {
	return getTypeName(v) === "regexp";
}
/**
* Checks if the input is a date
* @category Is
*/
function isDate(v) {
	return getTypeName(v) === "date";
}
/**
* Checks if the input is an empty object
* @category Is
*/
function isEmptyObject(v) {
	if (!isPlainObject(v)) return false;
	for (const _ in v) return false;
	return true;
}
/**
* Checks if the input is a blob
* @category Is
*/
function isBlob(v) {
	/* istanbul ignore if -- @preserve */
	if (typeof Blob === "undefined") return false;
	return v instanceof Blob;
}
/**
* Checks if the input is a typed array
* @category Is
*/
function isTypedArray(v) {
	return ArrayBuffer.isView(v) && !(v instanceof DataView);
}
/**
* Checks if the input is a window
* @category Is
*/
function isWindow(v) {
	/* istanbul ignore next -- @preserve */
	return typeof v !== "undefined" && getTypeName(v) === "window";
}
/**
* Checks if the input is a browser
* @category Is
*/
function isBrowser() {
	/* istanbul ignore next -- @preserve */
	return typeof window !== "undefined";
}
/**
* Checks if a value is a JSON object.
* @category Is
*/
function isJSONObject(obj) {
	if (!isPlainObject(obj)) return false;
	const keys = Reflect.ownKeys(obj);
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		const value = obj[key];
		/* istanbul ignore if -- @preserve */
		if (typeof key !== "string") return false;
		if (!isJSONValue(value)) return false;
	}
	return true;
}
/**
* Checks if a given value is a valid JSON array.
* @category Is
*/
function isJSONArray(value) {
	if (!Array.isArray(value)) return false;
	return value.every((item) => isJSONValue(item));
}
/**
* Checks if a given value is a valid JSON value.
* @category Is
*/
function isJSONValue(value) {
	switch (typeof value) {
		case "object": return value === null || isJSONArray(value) || isJSONObject(value);
		case "string":
		case "number":
		case "boolean": return true;
		default: return false;
	}
}

//#endregion
//#region src/array.ts
/**
* Convert `Arrayable<T>` to `Array<T>`
*
* å°† `Arrayable<T>` è½¬æ¢ä¸º `Array<T>`
*
* @category Array
* @example
* ```ts
* toArray(null) // => []
* toArray(undefined) // => []
* toArray([]) // => []
* toArray(1) // => [1]
* ```
*/
function toArray(v) {
	if (v === null || v === void 0) return [];
	if (isArray(v)) return v;
	return [v];
}
/**
* Unique array
*
* æ•°ç»„å»é‡
*
* @category Array
* @example
* ```ts
* uniq([1, 1, 2, 2, 3, 3]) // => [1, 2, 3]
* ```
*/
function uniq(v) {
	return Array.from(new Set(v));
}
/**
* Unique array by a custom equality function
*
* é€šè¿‡è‡ªå®šä¹‰ç›¸ç­‰å‡½æ•°å®ç°æ•°ç»„å»é‡
*
* @category Array
* @example
* ```ts
* uniqueBy([1, 1, 2, 2, 3, 3], (a, b) => a === b) // => [1, 2, 3]
* ```
*/
function uniqueBy(array, equalFn) {
	return array.reduce((acc, cur) => {
		if (acc.findIndex((item) => equalFn(cur, item)) === -1) acc.push(cur);
		return acc;
	}, []);
}
/**
* Remove value from array
*
* ä»æ•°ç»„ä¸­ç§»é™¤å€¼
*
* @category Array
*
* @param array - the array
* @param value - the value to remove - å¾…ç§»é™¤çš„å€¼
* @returns - if `true`, the value is removed, `false` otherwise.
*          - å¦‚æœæˆåŠŸç§»é™¤,è¿”å› `true`, å¦åˆ™è¿”å› `false`
*
* @example
* ```ts
* const arr = [1, 2, 3]
* remove(arr, 2) // => true
* console.log(arr) // => [1, 3]
* remove(arr, 4) // => false
* ```
*/
function remove(array, value) {
	if (!isArray(array)) return false;
	const index = array.indexOf(value);
	if (index !== -1) {
		array.splice(index, 1);
		return true;
	}
	return false;
}
/**
* Generate a range array of numbers. The `stop` is exclusive.
*
* ç”Ÿæˆä¸€ä¸ªæ•°å­—èŒƒå›´çš„æ•°ç»„, `stop` æ˜¯ä¸åŒ…å«çš„ã€‚
*
* @param args
* @returns - a range array of numbers / è¿”å›ä¸€ä¸ªæ•°å­—èŒƒå›´çš„æ•°ç»„
*/
function range(...args) {
	let start, stop, step;
	if (args.length === 1) {
		start = 0;
		stop = args[0];
		step = 1;
	} else [start, stop, step = 1] = args;
	const arr = [];
	let current = start;
	while (current < stop) {
		arr.push(current);
		current += step || 1;
	}
	return arr;
}
/**
* Move item in an array
*
* ç§»åŠ¨æ•°ç»„ä¸­çš„é¡¹
*
* @category Array
*
* @param arr - the array
* @param from - the index of the item to move. è¦ç§»åŠ¨çš„é¡¹çš„ç´¢å¼•
* @param to - the index to move to. è¦ç§»åŠ¨åˆ°çš„ç´¢å¼•
* @returns the array with the item moved. è¿”å›ç§»åŠ¨åçš„æ•°ç»„
* @example
* ```ts
* move([1, 2, 3], 0, 2) // => [3, 1, 2]
* ```
*/
function move(arr, from, to) {
	if (!isArray(arr) || arr.length === 0) return arr;
	arr.splice(to, 0, arr.splice(from, 1)[0]);
	return arr;
}
/**
* Shuffle array
*
* æ•°ç»„æ´—ç‰Œï¼Œéšæœºæ‰“ä¹±æ•°ç»„ä¸­çš„é¡ºåº
*
* @category Array
* @example
* ```ts
* shuffle([1, 2, 3]) // => [1, 3, 2]
* ```
*/
function shuffle(array) {
	for (let i = array.length - 1; i > 0; i--) {
		const j = Math.floor(Math.random() * (i + 1));
		[array[i], array[j]] = [array[j], array[i]];
	}
	return array;
}
/**
* Sort array
*
* æ•°ç»„æ’åº
*
* @category Array
* @example
* ```ts
* const arr = [
*  { name: 'Mark', age: 20 },
*  { name: 'John', age: 18 },
*  { name: 'Jack', age: 21 },
*  { name: 'Tom', age: 18 },
* ]
* sortBy(arr, (item) => item.age) // => [ { name: 'John', age: 18 }, { name: 'Tom', age: 18 }, { name: 'Mark', age: 20 }, { name: 'Jack', age: 21 } ]
* ```
*/
function sortBy(array, cb) {
	if (array.length === 0) return [];
	return array.sort((a, b) => {
		const s1 = cb(a);
		const s2 = cb(b);
		return s1 > s2 ? 1 : s2 > s1 ? -1 : 0;
	});
}
/**
* Split array into chunks
*
* å°†æ•°ç»„æ‹†åˆ†æˆå—
*
* @category Array
*
* @param input - the array
* @param size - the chunk size. å—çš„å¤§å°
*
* @example
* ```ts
* chunk([1, 2, 3, 4, 5], 2) // => [[1, 2], [3, 4], [5]]
* ```
*/
function chunk(input, size = 1) {
	const chunks = [];
	for (let i = 0; i < input.length; i += size) chunks.push(input.slice(i, i + size));
	return chunks;
}
/**
* Union two arrays
*
* ä¸¤ä¸ªæ•°ç»„çš„å¹¶é›†
*
* @category Array
*
* @example
* ```ts
* union([1, 2, 3], [2, 4, 5, 6]) // => [1, 2, 3, 4, 5, 6]
* ```
*/
function union(a, b) {
	return [...new Set([...a, ...b])];
}
/**
* Intersection of two arrays
*
* ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†
*
* @category Array
* @example
* ```ts
* intersection([1, 2, 3], [2, 4, 5, 6]) // => [2]
* ```
*/
function intersection(firstArr, secondArr) {
	const secondSet = new Set(secondArr);
	return firstArr.filter((item) => {
		return secondSet.has(item);
	});
}

//#endregion
//#region src/guard.ts
/**
* guard function that returns if val is truthy
*
* å®ˆå«å‡½æ•°ï¼Œè¿”å› val æ˜¯å¦ä¸ºçœŸå€¼
*
* @category Function
* @example
* ```ts
* [1, 2, 3, '', false, undefined].filter(isTruthy) // => [1, 2, 3]
* ```
*/
function isTruthy(val) {
	return Boolean(val);
}
/**
* guard function that returns if val is not undefined
*
* å®ˆå«å‡½æ•°ï¼Œè¿”å› val ä¸ä¸º undefined
*
* @category Function
* @example
* ```ts
* [1, '', false, undefined].filter(NotUndefined) // => [1, '', false]
* ```
*/
function notUndefined(val) {
	return typeof val !== "undefined";
}
/**
* guard function that returns if val is not null or undefined
*
* å®ˆå«å‡½æ•°ï¼Œè¿”å› val ä¸ä¸º null æˆ– undefined
*
* @category Function
* @example
* ```ts
* [1, '', false, null, undefined].filter(notNullish) // => [1, '', false]
* ```
*/
function notNullish(val) {
	return val != null;
}

//#endregion
//#region src/object.ts
/**
* Check if an object has a non-inherited property
*
* æ£€æŸ¥ä¸€ä¸ªå¯¹è±¡æ˜¯å¦å…·æœ‰éç»§æ‰¿å±æ€§
*
* @category Object
*/
function hasOwn(obj, key) {
	return obj === null ? false : Object.prototype.hasOwnProperty.call(obj, key);
}
/**
* Freeze an object recursively and its properties
*
* é€’å½’å†»ç»“ä¸€ä¸ªå¯¹è±¡åŠå…¶å±æ€§
*
* @category Object
*/
function deepFreeze(obj) {
	if (isArray(obj)) for (let i = 0; i < obj.length; i++) deepFreeze(obj[i]);
	else if (isPlainObject(obj)) {
		Object.freeze(obj);
		const keys = Object.keys(obj);
		for (let i = 0; i < keys.length; i++) deepFreeze(obj[keys[i]]);
	}
	return obj;
}
/**
* Check if an object has a property
*
* æ£€æŸ¥ä¸€ä¸ªå¯¹è±¡æ˜¯å¦æœ‰å±æ€§
*
* @category Object
*/
function isKeyof(obj, key) {
	return key in obj;
}
/**
* Get a value from an object
*
* ä»ä¸€ä¸ªå¯¹è±¡ä¸­è·å–ä¸€ä¸ªå€¼
*
* @category Object
* @example
* ```ts
* objectGet({ a: 1 }, 'a') // => 1
* objectGet({ a: { b: 2 } }, 'a.b') // => 2
* objectGet({ a: [{ b: 2 }] }, 'a[0].b') // => 2
* ```
*/
function objectGet(source, path) {
	const keys = path.replace(/\[['"]?(.+?)['"]?\]/g, ".$1").split(".");
	let res = source;
	for (const k of keys) res = res?.[k];
	return res;
}
/**
* Map key/value pairs for an object, and construct a new one
*
* ä¸ºä¸€ä¸ªå¯¹è±¡æ˜ å°„é”®å€¼å¯¹ï¼Œå¹¶æ„é€ ä¸€ä¸ªæ–°å¯¹è±¡
*
* @category Object
*
* Transform:
* @example
* ```
* objectMap({ a: 1, b: 2 }, (k, v) => [k.toString().toUpperCase(), v.toString()])
* // { A: '1', B: '2' }
* ```
*
* Swap key/value:
* @example
* ```
* objectMap({ a: 1, b: 2 }, (k, v) => [v, k])
* // { 1: 'a', 2: 'b' }
* ```
*
* Filter keys:
* @example
* ```
* objectMap({ a: 1, b: 2 }, (k, v) => k === 'a' ? undefined : [k, v])
* // { b: 2 }
* ```
*/
function objectMap(obj, fn) {
	return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));
}
/**
* Strict typed `Object.keys`
*
* @category Object
* @example
* ```ts
* objectKeys({ a: 1, b: 2 }) // => ['a', 'b']
* ```
*/
function objectKeys(obj) {
	return Object.keys(obj);
}
/**
* Strict typed `Object.entries`
*
* @category Object
* @example
* ```ts
* objectEntries({ a: 1, b: 2 }) // => [['a', 1], ['b', 2]]
* ```
*/
function objectEntries(obj) {
	return Object.entries(obj);
}
/**
* Creates a new object with specified keys omitted.
*
* åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡ï¼Œçœç•¥æŒ‡å®šçš„é”®ã€‚
*
* @category Object
* @example
* ```ts
* omit({ a: 1, b: 2 }, ['a']) // => { b: 2 }
* ```
*/
function omit(obj, keys) {
	const res = { ...obj };
	for (const key of keys) if (isKeyof(obj, key)) delete res[key];
	return res;
}
/**
* Creates a new object composed of the picked object properties.
*
* åˆ›å»ºä¸€ä¸ªç”±æ‰€é€‰å¯¹è±¡å±æ€§ç»„æˆçš„æ–°å¯¹è±¡ã€‚
*
* @category Object
* @example
* ```ts
* pick({ a: 1, b: 2 }, ['a']) // => { a: 1 }
* ```
*/
function pick(obj, keys) {
	const res = {};
	for (const key of keys) if (isKeyof(obj, key)) res[key] = obj[key];
	return res;
}
/**
* Deep merge
*
* The first argument is the target object, the rest are the sources.
* The target object will be mutated and returned.
*
* æ·±åº¦åˆå¹¶
*
* ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç›®æ ‡å¯¹è±¡ï¼Œå…¶ä½™çš„æ˜¯æºå¯¹è±¡ã€‚
* ç›®æ ‡å¯¹è±¡å°†è¢«ä¿®æ”¹å¹¶è¿”å›ã€‚
*
* @category Object
*/
function deepMerge(target, ...sources) {
	if (!sources.length) return target;
	const source = sources.shift();
	if (source === void 0) return target;
	if (isMergableObject(target) && isMergableObject(source)) {
		const keys = Object.keys(source);
		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			if (key === "__proto__" || key === "constructor" || key === "prototype") continue;
			if (isMergableObject(source[key])) {
				if (!target[key]) target[key] = {};
				deepMerge(target[key], source[key]);
			} else target[key] = source[key];
		}
	}
	return deepMerge(target, ...sources);
}
/**
* Deep merge
*
* Differs from `deepMerge` in that it merges arrays instead of overriding them.
*
* The first argument is the target object, the rest are the sources.
* The target object will be mutated and returned.
*
* æ·±åº¦åˆå¹¶
*
* ä¸ `deepMerge` ä¸åŒï¼Œå®ƒåˆå¹¶æ•°ç»„è€Œä¸æ˜¯è¦†ç›–å®ƒä»¬ã€‚
*
* ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç›®æ ‡å¯¹è±¡ï¼Œå…¶ä½™çš„æ˜¯æºã€‚
* ç›®æ ‡å¯¹è±¡å°†è¢«ä¿®æ”¹å¹¶è¿”å›ã€‚
*
* @category Object
*/
function deepMergeWithArray(target, ...sources) {
	if (!sources.length) return target;
	const source = sources.shift();
	if (source === void 0) return target;
	if (Array.isArray(target) && Array.isArray(source)) target.push(...source);
	if (isMergableObject(target) && isMergableObject(source)) {
		const keys = Object.keys(source);
		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			if (key === "__proto__" || key === "constructor" || key === "prototype") continue;
			if (Array.isArray(source[key])) {
				if (!target[key]) target[key] = [];
				deepMergeWithArray(target[key], source[key]);
			} else if (isMergableObject(source[key])) {
				if (!target[key]) target[key] = {};
				deepMergeWithArray(target[key], source[key]);
			} else target[key] = source[key];
		}
	}
	return deepMergeWithArray(target, ...sources);
}
function isMergableObject(item) {
	return isPlainObject(item) && !Array.isArray(item);
}

//#endregion
//#region src/_internal/deepCloneImpl.ts
function deepCloneImpl(valueToClone, objectToClone, stack = /* @__PURE__ */ new Map()) {
	if (isPrimitive(valueToClone)) return valueToClone;
	/* istanbul ignore if -- @preserve */
	if (stack.has(valueToClone)) return stack.get(valueToClone);
	if (Array.isArray(valueToClone)) {
		const result = Array.from({ length: valueToClone.length });
		stack.set(valueToClone, result);
		for (let i = 0; i < valueToClone.length; i++) result[i] = deepCloneImpl(valueToClone[i], objectToClone, stack);
		if (Object.hasOwn(valueToClone, "index")) result.index = valueToClone.index;
		if (Object.hasOwn(valueToClone, "input")) result.input = valueToClone.input;
		return result;
	}
	if (valueToClone instanceof Date) return new Date(valueToClone.getTime());
	if (valueToClone instanceof RegExp) {
		const result = new RegExp(valueToClone.source, valueToClone.flags);
		result.lastIndex = valueToClone.lastIndex;
		return result;
	}
	if (valueToClone instanceof Map) {
		const result = /* @__PURE__ */ new Map();
		stack.set(valueToClone, result);
		for (const [key, value] of valueToClone) result.set(key, deepCloneImpl(value, objectToClone, stack));
		return result;
	}
	if (valueToClone instanceof Set) {
		const result = /* @__PURE__ */ new Set();
		stack.set(valueToClone, result);
		for (const value of valueToClone) result.add(deepCloneImpl(value, objectToClone, stack));
		return result;
	}
	if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) return valueToClone.subarray();
	if (isTypedArray(valueToClone)) {
		const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
		stack.set(valueToClone, result);
		for (let i = 0; i < valueToClone.length; i++) result[i] = deepCloneImpl(valueToClone[i], objectToClone, stack);
		return result;
	}
	if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) return valueToClone.slice(0);
	if (valueToClone instanceof DataView) {
		const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	if (typeof File !== "undefined" && valueToClone instanceof File) {
		const result = new File([valueToClone], valueToClone.name, { type: valueToClone.type });
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	if (valueToClone instanceof Blob) {
		const result = new Blob([valueToClone], { type: valueToClone.type });
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	if (valueToClone instanceof Error) {
		const result = new valueToClone.constructor(valueToClone.message, { cause: valueToClone.cause });
		stack.set(valueToClone, result);
		if (hasOwn(valueToClone, "name")) result.name = valueToClone.name;
		result.stack = valueToClone.stack;
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	/* istanbul ignore if -- @preserve */
	if (typeof valueToClone === "object" && valueToClone !== null) {
		const result = Object.create(Object.getPrototypeOf(valueToClone));
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	/* istanbul ignore next -- @preserve */
	return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack) {
	const keys = [...Object.keys(source), ...getSymbols(source)];
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		const descriptor = Object.getOwnPropertyDescriptor(target, key);
		if (descriptor == null || descriptor.writable) target[key] = deepCloneImpl(source[key], objectToClone, stack);
	}
}
function getSymbols(object) {
	return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}

//#endregion
//#region src/clone.ts
/**
* clone data
*
* å…‹éš†æ•°æ®
*
* @module Clone
*/
/**
* simple clone, use JSON.parse and JSON.stringify
*
* ç®€å•çš„å…‹éš†,ä½¿ç”¨ JSON.parse å’Œ JSON.stringify
* @category Clone
*/
function simpleClone(source) {
	return JSON.parse(JSON.stringify(source));
}
/**
* shallow clone, only clone the first level
*
* æµ…å…‹éš†,åªå…‹éš†ç¬¬ä¸€å±‚
*
* @category Clone
*/
function shallowClone(source) {
	if (isPrimitive(source)) return source;
	if (isArray(source) || isTypedArray(source) || source instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && source instanceof SharedArrayBuffer) return source.slice(0);
	const prototype = Object.getPrototypeOf(source);
	const Constructor = prototype.constructor;
	if (source instanceof Date || source instanceof Map || source instanceof Set) return new Constructor(source);
	if (source instanceof RegExp) {
		const newRegExp = new Constructor(source);
		newRegExp.lastIndex = source.lastIndex;
		return newRegExp;
	}
	if (source instanceof DataView) return new Constructor(source.buffer.slice(0));
	if (source instanceof Error) {
		const newError = new Constructor(source.message, { cause: source.cause });
		if (hasOwn(source, "name")) newError.name = source.name;
		newError.stack = source.stack;
		return newError;
	}
	if (typeof File !== "undefined" && source instanceof File) return new Constructor([source], source.name, {
		type: source.type,
		lastModified: source.lastModified
	});
	/* istanbul ignore if -- @preserve */
	if (isPlainObject(source)) return Object.assign(Object.create(prototype), source);
	/* istanbul ignore next -- @preserve */
	return source;
}
/**
* Deep Clone.
*
* æ·±åº¦å…‹éš†
*
* @category Clone
*/
function deepClone(source) {
	return deepCloneImpl(source, source, /* @__PURE__ */ new Map());
}

//#endregion
//#region src/equal.ts
/**
* Equal
*
* @module Equal
*/
/**
* Deep equality two values, support array and object
*
* @category Equal
*/
function deepEqual(v1, v2) {
	const type1 = getTypeName(v1);
	if (type1 !== getTypeName(v2)) return false;
	if (type1 === "array") {
		if (v1.length !== v2.length) return false;
		return v1.every((item, index) => deepEqual(item, v2[index]));
	}
	if (type1 === "object") {
		const keys1 = Object.keys(v1);
		if (keys1.length !== Object.keys(v2).length) return false;
		return keys1.every((key) => deepEqual(v1[key], v2[key]));
	}
	return Object.is(v1, v2);
}

//#endregion
//#region src/event.ts
/**
* Base Event
*
* @module Event
*/
/**
* @category Event
*/
var BaseEvent = class {
	_listeners;
	constructor() {
		this._listeners = /* @__PURE__ */ new Map();
	}
	/**
	* Adds a listener to the specified event.
	*
	* @param event - the event to listen for
	* @param listener - the listener function to be called when the event is triggered
	* @return
	*/
	on(event, listener) {
		if (!this._listeners.has(event)) this._listeners.set(event, []);
		this._listeners.get(event).push(listener);
	}
	/**
	* Emits the specified event with the given arguments to all registered listeners.
	*
	* @param event - the name of the event to emit
	* @param args - the arguments to pass to the event listeners
	* @return
	*/
	emit(event, ...args) {
		if (this._listeners.has(event)) this._listeners.get(event).forEach((listener) => listener(...args));
	}
	/**
	* Turn off the specified event listener.
	*
	* @param event - the name of the event to turn off
	* @param listener - (optional) the listener function to turn off
	*/
	off(event, listener) {
		if (this._listeners.has(event)) listener ? this._listeners.get(event).splice(this._listeners.get(event).indexOf(listener), 1) : this._listeners.delete(event);
	}
	/**
	* Execute the listener at most once for a particular event.
	*
	* @param event - the event to listen for
	* @param listener - the function to be executed once for the event
	*/
	once(event, listener) {
		this.on(event, (...args) => {
			this.off(event, listener);
			listener(...args);
		});
	}
};

//#endregion
//#region src/function.ts
/**
* noop function
*
* ç©ºå‡½æ•°
*
* @category Function
*/
function noop() {}
/**
* Create a function that can only be called once,
* and repeated calls return the result of the first call
*
* åˆ›å»ºåªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡çš„å‡½æ•°ï¼Œé‡å¤è°ƒç”¨è¿”å›ç¬¬ä¸€æ¬¡è°ƒç”¨çš„ç»“æœ
*
* @category Function
*/
function once(func) {
	let called = false;
	let res;
	return ((...args) => {
		if (!called) {
			called = true;
			res = func(...args);
			return res;
		}
		return res;
	});
}
function invoke(fns) {
	if (Array.isArray(fns)) fns.forEach((fn) => fn && fn());
	else return fns();
}
/**
* compose multiple functions, right to left
*
* ç»„åˆå¤šä¸ªå‡½æ•°ï¼Œä»å³åˆ°å·¦æ‰§è¡Œ
*
* @category Function
* @example
* ```ts
* const add = (a) => a + 1
* const subtract = (a) => a - 2
* const multiply = (a, b) => a * b
* compose(add, subtract, multiply)(1, 2) => (1 * 2) - 2 + 1 = 1
* ```
*/
function compose(...fns) {
	return function(...args) {
		const len = fns.length;
		if (len === 0) return args;
		if (len === 1) return fns[0](...args);
		return fns.slice(0, -1).reduceRight((acc, fn) => fn(acc), fns[len - 1](...args));
	};
}

//#endregion
//#region src/math.ts
/**
* Math Helpers
*
* @module Math
*/
/**
* Clamp a number between min and max
*
* è¿”å›ä¸€ä¸ªä»‹äºæœ€å°å€¼å’Œæœ€å¤§å€¼ä¹‹é—´çš„æ•°å­—
*
* @category Math
*/
function clamp(n, min, max) {
	return Math.min(max, Math.max(n, min));
}
function inRange(n, min, max) {
	if (max === void 0) {
		max = min;
		min = 0;
	}
	return n >= Math.min(min, max) && n <= Math.max(min, max);
}
/**
* Random number between min and max
*
* è¿”å›ä¸€ä¸ªä»‹äº min å’Œ max ä¹‹é—´çš„éšæœºæ•°
*
* @param args
* @returns a random number / è¿”å›ä¸€ä¸ªéšæœºæ•°
*/
function random(...args) {
	let min, max, float;
	if (args.length === 1) {
		min = 0;
		max = args[0];
		float = false;
	} else if (typeof args[1] === "number") {
		min = args[0];
		max = args[1];
		float = !!args[2];
	} else {
		min = 0;
		max = args[0];
		float = !!args[1];
	}
	const num = Math.random() * (max - min) + min;
	return float ? num : Math.floor(num);
}

//#endregion
//#region src/promise.ts
/**
* Sleeps for the given number of milliseconds.
*
* ç»™å®šæ¯«ç§’æ•°ç¡çœ ã€‚
* @param ms - the number of milliseconds to sleep. ç¡çœ çš„æ¯«ç§’æ•°
* @param callback - (optional) the function to execute after the sleep. ç¡çœ å®Œæˆåæ‰§è¡Œçš„å‡½æ•°ã€‚
* @returns a promise
*/
async function sleep(ms, callback) {
	return new Promise((resolve) => setTimeout(async () => {
		await callback?.();
		resolve();
	}, ms));
}
/**
* Executes an array of promises in parallel with a given concurrency. The function
* returns a Promise that resolves with an array containing the resolved values of
* each promise.
* If any promise is rejected, the returned promise will be rejected.
*
* ä»¥æŒ‡å®šçš„å¹¶å‘æ•°å¹¶è¡Œæ‰§è¡Œä¸€ç»„ promiseã€‚è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª promiseï¼Œè¯¥æ‰¿è¯ºè§£æä¸ºä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«æ¯ä¸ª promise çš„è§£æå€¼ã€‚
* ä»»æ„ä¸€ä¸ª promise æ‹’ç»ï¼Œè¿”å›çš„ promise å°†è¢«æ‹’ç»ã€‚
*
* @category Promise
*
* @param promises - the array of promises to execute
* @param concurrency - (optional) the maximum number of promises to execute in parallel æœ€å¤§å¹¶å‘æ•°
*/
function promiseParallel(promises, concurrency = Number.POSITIVE_INFINITY) {
	promises = Array.from(promises);
	let current = 0;
	const result = [];
	let resolvedCount = 0;
	const len = promises.length;
	return new Promise((resolve, reject) => {
		function next() {
			const index = current++;
			const promise = promises[index];
			Promise.resolve(isFunction(promise) ? promise() : promise).then((res) => {
				result[index] = res;
				if (++resolvedCount === len) resolve(result);
				if (current < len) next();
			}).catch((reason) => reject(reason));
		}
		for (let i = 0; i < concurrency && i < len; i++) next();
	});
}
/**
* Creates a promise that is resolved with an array of promise settlement results,
* in the same order as the input promises array.
* The returned promise will be fulfilled when all of the input promises have settled,
* either fulfilled or rejected.
*
* åˆ›å»ºä¸€ä¸ªä»¥è¾“å…¥ promise æ•°ç»„çš„ç»“æœæ•°ç»„è§£å†³çš„ promiseï¼Œ
* æŒ‰ç…§è¾“å…¥ promise æ•°ç»„çš„ç›¸åŒé¡ºåºã€‚
* å½“æ‰€æœ‰è¾“å…¥ promise éƒ½å·²è§£å†³æ—¶ï¼Œè¿”å›çš„ promiseå°†è¢«å®ç°ï¼Œ
* è¦ä¹ˆå®ç°ï¼Œè¦ä¹ˆæ‹’ç»ã€‚
*
* @category Promise
*
* @param promises - the array of promises to execute
* @param concurrency - (optional) the maximum number of promises to execute in parallel
*/
function promiseParallelSettled(promises, concurrency = Number.POSITIVE_INFINITY) {
	promises = Array.from(promises);
	let current = 0;
	const result = [];
	let resolvedCount = 0;
	const len = promises.length;
	return new Promise((resolve) => {
		function resolved() {
			if (++resolvedCount === len) resolve(result);
			if (current < len) next();
		}
		function next() {
			const index = current++;
			const promise = promises[index];
			Promise.resolve(isFunction(promise) ? promise() : promise).then((value) => {
				result[index] = {
					status: "fulfilled",
					value
				};
				resolved();
			}).catch((reason) => {
				result[index] = {
					status: "rejected",
					reason
				};
				resolved();
			});
		}
		for (let i = 0; i < concurrency && i < len; i++) next();
	});
}
/**
* An error class representing an timeout operation.
* @category Promise
* @augments Error
*/
var TimeoutError = class extends Error {
	constructor(message = "The operation was timed out") {
		super(message);
		this.name = "TimeoutError";
	}
};
/**
* Returns a promise that rejects with a `TimeoutError` after a specified delay.
*
* è¿”å›ä¸€ä¸ª promiseï¼Œè¯¥ promise åœ¨æŒ‡å®šçš„å»¶è¿Ÿæ—¶é—´åæ‹’ç»ï¼ŒæŠ›å‡ºä¸€ä¸ª `TimeoutError`ã€‚
*
* @category Promise
* @param ms - the number of milliseconds to wait before rejecting the promise. è¶…æ—¶çš„æ¯«ç§’æ•°
* @throws Throws a `TimeoutError` after the specified delay.
* @example
* ```ts
* @example
* ```
* try {
*   await timeout(1000); // Timeout exception after 1 second
* } catch (error) {
*   console.error(error); // Will log 'The operation was timed out'
* }
* ```
*/
async function timeout(ms) {
	await sleep(ms);
	throw new TimeoutError();
}
/**
* Executes an async function and enforces a timeout.
*
* æ‰§è¡Œå¼‚æ­¥å‡½æ•°, è¶…æ—¶åˆ™å¼ºåˆ¶æ‹’ç»
*
* @category Promise
* @param run - the async function to execute.
* @param ms - the number of milliseconds to wait before rejecting the promise.
* @returns A promise that resolves with the result of the async function, or rejects with a `TimeoutError` if the function does not resolve within the specified timeout. ä¸€ä¸ª promiseï¼Œå®ƒå°†è§£æä¸ºå¼‚æ­¥å‡½æ•°çš„ç»“æœï¼Œæˆ–è€…å¦‚æœåœ¨æŒ‡å®šè¶…æ—¶å†…å‡½æ•°æœªè§£æï¼Œåˆ™æ‹’ç»å¹¶æŠ›å‡º`TimeoutError`ã€‚
* @example
* ```ts
* async function fetchData() {
*   const response = await fetch('https://example.com/data');
*   return response.json();
* }
*
* try {
*   const data = await withTimeout(fetchData, 1000);
*   console.log(data); // Logs the fetched data if `fetchData` is resolved within 1 second.
* } catch (error) {
*   console.error(error); // Will log 'TimeoutError' if `fetchData` is not resolved within 1 second.
* }
* ```
*/
async function withTimeout(run, ms) {
	return Promise.race([run(), timeout(ms)]);
}
/**
* Create singleton promise function
*
* åˆ›å»ºå•ä¾‹ promise
*
* @category Promise
*/
function createSingletonPromise(fn) {
	let _promise;
	function wrapper() {
		if (!_promise) _promise = fn();
		return _promise;
	}
	wrapper.reset = async () => {
		const _prev = _promise;
		_promise = void 0;
		if (_prev) await _prev;
	};
	return wrapper;
}
/**
* Create a promise lock
*
* åˆ›å»ºä¸€ä¸ª promise é”
*
* @category Promise
* @example
* ```
* const lock = createPromiseLock()
*
* lock.run(async () => {
*   await doSomething()
* })
*
* // in anther context:
* await lock.wait() // it will wait all tasking finished
* ```
*/
function createPromiseLock() {
	const locks = [];
	return {
		async run(fn) {
			const p = fn();
			locks.push(p);
			try {
				return await p;
			} finally {
				remove(locks, p);
			}
		},
		async wait() {
			await Promise.allSettled(locks);
		},
		isWaiting() {
			return Boolean(locks.length);
		},
		clear() {
			locks.length = 0;
		}
	};
}
/**
* Return a Promise with `resolve` and `reject` methods
*
* è¿”å›ä¸€ä¸ª Promiseï¼Œå¸¦æœ‰ `resolve` å’Œ `reject` æ–¹æ³•
*
* @category Promise
* @example
* ```
* const promise = createControlledPromise()
*
* await promise
*
* // in anther context:
* promise.resolve(data)
* ```
*/
function createControlledPromise() {
	let resolve, reject;
	const promise = new Promise((_resolve, _reject) => {
		resolve = _resolve;
		reject = _reject;
	});
	promise.resolve = resolve;
	promise.reject = reject;
	return promise;
}

//#endregion
//#region src/string.ts
/**
* String Helpers
*
* @module String
*/
/**
* Ensure prefix, if str does not start with prefix, it will be added
*
* ç¡®ä¿å‰ç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥å‰ç¼€å¼€å¤´ï¼Œåˆ™å°†æ·»åŠ å‰ç¼€ã€‚
*
* @category String
*
* @example
* ```ts
* ensurePrefix('http://', 'example.com') // => http://example.com
* ensurePrefix('//', '//example.com') // => //example.com
* ```
*/
function ensurePrefix(prefix, str) {
	if (str.startsWith(prefix)) return str;
	return prefix + str;
}
/**
* Ensure suffix, if str does not end with suffix, it will be added
*
* ç¡®ä¿åç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥è¯¥åç¼€ç»“å°¾ï¼Œåˆ™å°†æ·»åŠ è¯¥åç¼€ã€‚
*
* @category String
*
* @example
* ```ts
* ensureSuffix('.com', 'example.com') // => example.com
* ensureSuffix('.com', 'example') // => example.com
* ```
*/
function ensureSuffix(suffix, str) {
	if (str.endsWith(suffix)) return str;
	return str + suffix;
}
const CASE_SPLIT_PATTERN = /\p{Lu}?\p{Ll}+|\d+|\p{Lu}+(?!\p{Ll})|[\p{Emoji_Presentation}\p{Extended_Pictographic}]|\p{L}+/gu;
/**
* Split string into as words array
*
* å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå•è¯æ•°ç»„
*
* @category String
* @example
* ```ts
* words('helloWorldğŸš€') // => ['hello', 'world', 'ğŸš€']
* ```
*/
function words(str) {
	return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
}
/**
* First letter uppercase, other lowercase
* @category String
* @example
* ```ts
* capitalize('hello') // 'Hello'
* ```
*/
function capitalize(s) {
	if (!s) return s;
	return s[0].toUpperCase() + s.slice(1).toLowerCase();
}
/**
* Convert string to kebab-case
* @category String
*
* @example
* ```ts
* kebabCase('a b c') // => a-b-c
* kebabCase('orderBy') // => order-by
* ```
*/
function kebabCase(str) {
	const parts = words(str);
	if (parts.length === 0) return "";
	return parts.map((word) => word.toLowerCase()).join("-");
}
/**
* Convert string to snake_case
* @category String
* @example
* ```ts
* snakeCase('a b c') // => a_b_c
* snakeCase('orderBy') // => order_by
* ```
*/
function snakeCase(str) {
	const parts = words(str);
	if (parts.length === 0) return "";
	return parts.map((word) => word.toLowerCase()).join("_");
}
/**
* Convert string to camelCase
*
* @category String
*
* @example
* ```ts
* camelCase('foo bar') // => fooBar
* camelCase('foo-bar') // => fooBar
* ```
*/
function camelCase(str) {
	const parts = words(str);
	if (parts.length === 0) return "";
	const [first, ...rest] = parts;
	return `${first.toLowerCase()}${rest.map((word) => capitalize(word)).join("")}`;
}
/**
* Convert string to lowercase
* @category String
* @example
* ```ts
* lowerCase('Hello World') // => 'hello world'
* lowerCase('HELLO WORLD') // => 'hello world'
* lowerCase('order-by') // => 'order by'
* ```
*/
function lowerCase(str) {
	const parts = words(str);
	if (parts.length === 0) return "";
	return parts.map((word) => word.toLowerCase()).join(" ");
}
/**
* Convert string to uppercase
* @category String
* @example
* ```ts
* upperCase('Hello World') // => 'HELLO WORLD'
* upperCase('hello world') // => 'HELLO WORLD'
* upperCase('order-by') // => 'ORDER BY'
* ```
*/
function upperCase(str) {
	const parts = words(str);
	if (parts.length === 0) return "";
	return parts.map((word) => word.toUpperCase()).join(" ");
}
/**
* Converts a string to Pascal case.
* @category String
* @example
* ```ts
* pascalCase('foo bar') // => FooBar
* pascalCase('foo-bar') // => FooBar
* ```
*/
function pascalCase(str) {
	const parts = words(str);
	if (parts.length === 0) return "";
	return parts.map((word) => capitalize(word)).join("");
}
const htmlEscapes = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	"\"": "&quot;",
	"'": "&#39;"
};
const RE_ESCAPE = /[&<>"']/g;
/**
* Converts the characters "&", "<", ">", '"', and "'" in `str` to their corresponding HTML entities.
*
* å°†`str`ä¸­çš„å­—ç¬¦"&"ã€"<"ã€">"ã€'"'å’Œ"'"è½¬æ¢ä¸ºå¯¹åº”çš„HTMLå®ä½“ã€‚
*
* @category String
* @example
* ```ts
* escape('<script>alert(1)<\/script>') // => &lt;script&gt;alert(1)&lt;/script&gt;
* ```
*/
function escape(str) {
	return str.replace(RE_ESCAPE, (match) => htmlEscapes[match]);
}
const RE_ESCAPE_REGEXP = /[\\^$.*+?()[\]{}|]/g;
/**
* Escapes the RegExp special characters "^", "$", "\\", ".", "*", "+", "?", "(", ")", "[", "]", "{", "}", and "|" in `str`.
*
* è½¬ä¹‰`str`ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦"^"ã€"$"ã€"\\"ã€"."ã€"*"ã€"+"ã€"?"ã€"("ã€")"ã€"["ã€"]"ã€"{"ã€"}"ä»¥åŠ"|"ã€‚
*
* @category String
* @example
* ```ts
* escapeRegExp('[link](https://sub.domain.com/)'); // '\[link\]\(https://sub\.domain\.com/\)'
* ```
*/
function escapeRegExp(str) {
	return str.replace(RE_ESCAPE_REGEXP, "\\$&");
}
const htmlUnescapes = {
	"&amp;": "&",
	"&lt;": "<",
	"&gt;": ">",
	"&quot;": "\"",
	"&#39;": "'"
};
const RE_UNESCAPE = /&(?:amp|lt|gt|quot|#(0+)?39);/g;
/**
* Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.
* It is the inverse of `escape`.
*
* å°†`str`ä¸­çš„HTMLå®ä½“`&amp;`ã€`&lt;`ã€`&gt;`ã€`&quot;`å’Œ`&#39;`è½¬æ¢å›å¯¹åº”çš„å­—ç¬¦ã€‚
* æ­¤æ“ä½œæ˜¯`escape`çš„é€†å‘è¿‡ç¨‹ã€‚
*
* @category String
* @example
* ```ts
* unescape('&lt;script&gt;alert(1)&lt;/script&gt;') // => <script>alert(1)<\/script>
* ```
*/
function unescape(str) {
	return str.replace(RE_UNESCAPE, (match) => htmlUnescapes[match] || "'");
}

//#endregion
//#region src/throttle-debounce.ts
/**
* Throttle execution of a function. Especially useful for rate limiting
* execution of handlers on events like resize and scroll.
*
* @category Function
*
* @param delay
* A zero-or-greater delay in milliseconds. For event callbacks, values around
* 100 or 250 (or even higher) are most useful.
*
* @param callback
* A function to be executed after delay milliseconds. The `this` context and
* all arguments are passed through, as-is, to `callback` when the
* throttled-function is executed.
*
* @param options
* An object to configure options.
*
* @return
* A new, throttled, function.
*/
function throttle(delay, callback, options) {
	const { noTrailing = false, noLeading = false, debounceMode = void 0 } = options || {};
	/**
	* After wrapper has stopped being called, this timeout ensures that
	* `callback` is executed at the proper times in `throttle` and `end`
	* debounce modes.
	*/
	let timeoutID;
	let cancelled = false;
	let lastExec = 0;
	function clearExistingTimeout() {
		if (timeoutID) clearTimeout(timeoutID);
	}
	function cancel(options$1 = {}) {
		const { upcomingOnly = false } = options$1 || {};
		clearExistingTimeout();
		cancelled = !upcomingOnly;
	}
	/**
	* The `wrapper` function encapsulates all of the throttling / debouncing
	* functionality and when executed will limit the rate at which `callback`
	* is executed.
	*/
	function wrapper(...args) {
		const self = this;
		const elapsed = Date.now() - lastExec;
		if (cancelled) return;
		function exec() {
			lastExec = Date.now();
			callback.apply(self, args);
		}
		/**
		* If `debounceMode` is true (at begin) this is used to clear the flag
		* to allow future `callback` executions.
		*/
		function clear() {
			timeoutID = void 0;
		}
		if (!noLeading && debounceMode && !timeoutID)
 /**
		* Since `wrapper` is being called for the first time and
		* `debounceMode` is true (at begin), execute `callback`
		* and noLeading != true.
		*/
		exec();
		clearExistingTimeout();
		if (debounceMode === void 0 && elapsed > delay) if (noLeading) {
			/**
			* In throttle mode with noLeading, if `delay` time has
			* been exceeded, update `lastExec` and schedule `callback`
			* to execute after `delay` ms.
			*/
			lastExec = Date.now();
			if (!noTrailing) timeoutID = setTimeout(debounceMode ? clear : exec, delay);
		} else
 /**
		* In throttle mode without noLeading, if `delay` time has been exceeded, execute
		* `callback`.
		*/
		exec();
		else if (noTrailing !== true)
 /**
		* In trailing throttle mode, since `delay` time has not been
		* exceeded, schedule `callback` to execute `delay` ms after most
		* recent execution.
		*
		* If `debounceMode` is true (at begin), schedule `clear` to execute
		* after `delay` ms.
		*
		* If `debounceMode` is false (at end), schedule `callback` to
		* execute after `delay` ms.
		*/
		timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
	}
	wrapper.cancel = cancel;
	return wrapper;
}
/**
* Debounce execution of a function. Debouncing, unlike throttling,
* guarantees that a function is only executed a single time, either at the
* very beginning of a series of calls, or at the very end.
*
* @category Functions
*
* @param delay
* A zero-or-greater delay in milliseconds. For event callbacks, values around
* 100 or 250 (or even higher) are most useful.
*
* @param callback
* A function to be executed after delay milliseconds. The `this` context and
* all arguments are passed through, as-is, to `callback` when the
* debounced-function is executed.
*
* @param options
* An object to configure options.
*
* @return
* A new, debounced function.
*/
function debounce(delay, callback, options) {
	const { atBegin = false } = options || {};
	return throttle(delay, callback, { debounceMode: atBegin !== false });
}

//#endregion
//#region src/time.ts
/**
* Recommended time library:
*
* - [dayjs](https://day.js.org/)
* - [date-fns](https://date-fns.org)
*
* @module
*/
/**
* Get current timestamp
* @category Time
*/
function timestamp() {
	return +Date.now();
}
/**
* Check if two dates is same day
* @category Time
*/
function isSameDay(date1, date2) {
	if (!date2) return false;
	const v1 = new Date(date1);
	const v2 = new Date(date2);
	const y1 = v1.getFullYear();
	const m1 = v1.getMonth();
	const d1 = v1.getDate();
	const y2 = v2.getFullYear();
	const m2 = v2.getMonth();
	const d2 = v2.getDate();
	return y1 === y2 && m1 === m2 && d1 === d2;
}

//#endregion
//#region src/url.ts
/**
* URL Helpers
*
* @module URL
*/
/**
* Replace all backslashes with forward slashes
*
* å°†æ‰€æœ‰åæ–œæ æ›¿æ¢ä¸ºæ­£æ–œæ 
*
* @category String
* @example
* ```ts
* slash('foo\\bar') // => foo/bar
* ```
*/
function slash(s) {
	return s.replace(/\\/g, "/");
}
/**
* Ensure leading slash, if str does not start with slash, it will be added
*
* ç¡®ä¿å‰ç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥æ–œæ å¼€å¤´ï¼Œåˆ™å°†æ·»åŠ æ–œæ 
*
* @category String
* @example
* ```ts
* ensureLeadingSlash('foo/bar') // => /foo/bar
* ```
*/
function ensureLeadingSlash(str) {
	return ensurePrefix("/", slash(str));
}
/**
* Ensure trailing slash, if str does not end with slash, it will be added
*
* ç¡®ä¿åç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥æ–œæ ç»“å°¾ï¼Œåˆ™å°†æ·»åŠ æ–œæ 
*
* @category String
* @example
* ```ts
* ensureTrailingSlash('/foo/bar') // => /foo/bar/
* ```
*/
function ensureTrailingSlash(str) {
	return ensureSuffix("/", slash(str));
}
/**
* Remove leading slash, if str starts with slash, it will be removed
*
* åˆ é™¤æ–œæ†å‰ç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä»¥æ–œæ å¼€å¤´ï¼Œåˆ™å°†åˆ é™¤
*
* @category String
* @example
* ```ts
* removeLeadingSlash('/foo/bar') // => foo/bar
* ```
*/
function removeLeadingSlash(str) {
	if (!str) return str;
	str = slash(str);
	return str[0] === "/" ? str.slice(1) : str;
}
/**
* Remove trailing slash, if str ends with slash, it will be removed
*
* åˆ é™¤æ–œæ†åç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä»¥æ–œæ ç»“å°¾ï¼Œåˆ™å°†åˆ é™¤
*
* @category String
* @example
* ```ts
* removeTrailingSlash('/foo/bar/') // => /foo/bar
* ```
*/
function removeTrailingSlash(str) {
	if (!str) return str;
	str = slash(str);
	return str[str.length - 1] === "/" ? str.slice(0, -1) : str;
}
const RE_HTTP = /^(?:https?:)?\/\//i;
/**
* Check if url is http
* @category URL
*/
function isHttp(url) {
	return RE_HTTP.test(url);
}
/**
* Check if url is valid
* @category URL
*/
function isUrl(url) {
	try {
		new URL(url);
		return true;
	} catch {
		return false;
	}
}
/**
* combines urls
* @category URL
* @example
* ```ts
* combineURLs('http://example.com', 'foo', 'bar') // => http://example.com/foo/bar
* combineURLs('//example.com', '/foo') // => //example.com/foo
* combineURLs('/foo', 'bar', 'index.html') // => /foo/bar/index.html
* ```
*/
function combineURLs(baseUrl, ...urls) {
	if (urls.length === 0) return baseUrl;
	const url = removeLeadingSlash(urls.join("/").replace(/\/+/g, "/"));
	baseUrl = removeTrailingSlash(baseUrl);
	return `${baseUrl}/${url}`;
}
const RE_PROTOCOL_MATCH = /^([-+\w]{1,25})(?::?\/\/|:)/;
/**
* Parse protocol from url
*
* @category URL
* @example
* ```ts
* parseProtocol('http://example.com') // => http
* parseProtocol('mailto:user@example.com') // => mailto
* ```
*/
function parseProtocol(url) {
	return RE_PROTOCOL_MATCH.exec(url)?.[1] || "";
}

//#endregion
export { BaseEvent, CASE_SPLIT_PATTERN, TimeoutError, assert, camelCase, capitalize, chunk, clamp, combineURLs, compose, createControlledPromise, createPromiseLock, createSingletonPromise, debounce, deepClone, deepEqual, deepFreeze, deepMerge, deepMergeWithArray, ensureLeadingSlash, ensurePrefix, ensureSuffix, ensureTrailingSlash, escape, escapeRegExp, getTypeName, hasOwn, inRange, intersection, invoke, isArray, isBlob, isBoolean, isBrowser, isDate, isDef, isEmptyObject, isFunction, isHttp, isJSONArray, isJSONObject, isJSONValue, isKeyof, isNull, isNumber, isPlainObject, isPrimitive, isRegexp, isSameDay, isString, isSymbol, isTruthy, isTypedArray, isUndefined, isUrl, isWindow, kebabCase, lowerCase, move, noop, notNullish, notUndefined, objectEntries, objectGet, objectKeys, objectMap, omit, once, parseProtocol, pascalCase, pick, promiseParallel, promiseParallelSettled, random, range, remove, removeLeadingSlash, removeTrailingSlash, shallowClone, shuffle, simpleClone, slash, sleep, snakeCase, sortBy, throttle, timeout, timestamp, toArray, toString, unescape, union, uniq, uniqueBy, upperCase, withTimeout, words };